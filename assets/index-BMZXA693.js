import{i as $,r as aa,m as ea,a as ta,b as J,d as sa,c as na,f as ia,e as ra,s as oa,p as la,V as ua,g as ca,h as ma,j as fa,S as pa,H as ga,v as K,k as ha,l as da,n as ya}from"./index-CpVGqTrp.js";import{A as _a,K as qa,J as Ja,L as Za,b6 as Qa,av as Xa,N as Ya,w as $a,bd as ae,b2 as ee,aN as te,aF as se,bg as ne,ay as ie,bh as re,bi as oe,bj as le,G as ue,a_ as ce,bk as me,bl as fe,bm as pe,b3 as ge,aw as he,az as de,aG as ye,O as be,Y as Ae,bn as Ve,Q as Se,E as Te,a6 as Ee,aJ as ve,aQ as xe,aH as De,t as Oe,u as Me,bo as Ie,bp as Ne,bq as we,bu as Ce,P as Ge,aI as Fe,aY as Ke,M as Be,a$ as Le,b0 as je,b1 as Pe,X as Re,aX as ke,aK as We,ak as ze,aZ as He,z as Ue,x as _e,aA as qe,a2 as Je,aB as Ze,aC as Qe,D as Xe,af as Ye,b4 as $e,ap as at,bt as et,B as tt,C as st,$ as nt,a0 as it,ag as rt,a4 as ot,b7 as lt,b8 as ut,a5 as ct,b9 as mt,F as ft,R as pt,I as gt,ba as ht,Z as dt,be as yt,br as bt,ah as At,al as Vt,ai as St,am as Tt,ao as Et,aj as vt,an as xt,aq as Dt,ax as Ot,bb as Mt,aO as It,aL as Nt,ae as wt,y as Ct,a7 as Gt,aR as Ft,bc as Kt,aa as Bt,a3 as Lt,aS as jt,aT as Pt,a8 as Rt,ad as kt,bs as Wt,aD as zt,aE as Ht,aP as Ut,o as _t,q as qt,a1 as Jt,a9 as Zt,U as Qt,T as Xt,W as Yt,ar as $t,as,at as es,aW as ts,_ as ss,au as ns,ab as is,ac as rs,aM as os,bf as ls,aU as us,aV as cs,b5 as ms}from"./index-CpVGqTrp.js";const ba=(e,a,t)=>{const s=a-e;return((t-e)%s+s)%s+e};function Z(e,a){return $(e)?e[ba(0,e.length,a)]:e}class Aa{constructor(a){this.stop=()=>this.runAll("stop"),this.animations=a.filter(Boolean)}get finished(){return Promise.all(this.animations.map(a=>a.finished))}getAll(a){return this.animations[0][a]}setAll(a,t){for(let s=0;s<this.animations.length;s++)this.animations[s][a]=t}attachTimeline(a){const t=this.animations.map(s=>s.attachTimeline(a));return()=>{t.forEach((s,n)=>{s&&s(),this.animations[n].stop()})}}get time(){return this.getAll("time")}set time(a){this.setAll("time",a)}get speed(){return this.getAll("speed")}set speed(a){this.setAll("speed",a)}get state(){return this.getAll("state")}get startTime(){return this.getAll("startTime")}get duration(){let a=0;for(let t=0;t<this.animations.length;t++)a=Math.max(a,this.animations[t].duration);return a}runAll(a){this.animations.forEach(t=>t[a]())}play(){this.runAll("play")}pause(){this.runAll("pause")}cancel(){this.runAll("cancel")}complete(){this.runAll("complete")}}class Va extends Aa{then(a,t){return this.finished.finally(a).then(()=>{})}}function j(e){return typeof e=="object"&&!Array.isArray(e)}function Q(e,a,t,s){return typeof e=="string"&&j(a)?aa(e,t,s):e instanceof NodeList?Array.from(e):Array.isArray(e)?e:[e]}function Sa(e,a,t){return e*(a+1)}function U(e,a,t,s){return typeof a=="number"?a:a.startsWith("-")||a.startsWith("+")?Math.max(0,e+parseFloat(a)):a==="<"?t:a.startsWith("<")?Math.max(0,t+parseFloat(a.slice(1))):s.get(a)??e}function Ta(e,a,t){for(let s=0;s<e.length;s++){const n=e[s];n.at>a&&n.at<t&&(ta(e,n),s--)}}function Ea(e,a,t,s,n,o){Ta(e,n,o);for(let i=0;i<a.length;i++)e.push({value:a[i],at:ea(n,o,s[i]),easing:Z(t,i)})}function va(e,a){for(let t=0;t<e.length;t++)e[t]=e[t]/(a+1)}function xa(e,a){return e.at===a.at?e.value===null?1:a.value===null?-1:0:e.at-a.at}const Da="easeInOut";function Oa(e,{defaultTransition:a={},...t}={},s,n){const o=a.duration||.3,i=new Map,m=new Map,S={},T=new Map;let x=0,l=0,w=0;for(let E=0;E<e.length;E++){const f=e[E];if(typeof f=="string"){T.set(f,l);continue}else if(!Array.isArray(f)){T.set(f.name,U(l,f.at,x,T));continue}let[V,p,u={}]=f;u.at!==void 0&&(l=U(l,u.at,x,T));let c=0;const v=(g,h,b,D=0,O=0)=>{const r=Ma(g),{delay:B=0,times:d=sa(r),type:L="keyframes",repeat:C,repeatType:Ra,repeatDelay:ka=0,...Y}=h;let{ease:A=a.ease||"easeOut",duration:y}=h;const P=typeof B=="function"?B(D,O):B,R=r.length,k=ra(L)?L:n==null?void 0:n[L||"keyframes"];if(R<=2&&k){let M=100;if(R===2&&wa(r)){const I=r[1]-r[0];M=Math.abs(I)}const G={...Y};y!==void 0&&(G.duration=oa(y));const F=na(G,M,k);A=F.ease,y=F.duration}y??(y=o);const W=l+P;d.length===1&&d[0]===0&&(d[1]=1);const z=d.length-r.length;if(z>0&&ia(d,z),r.length===1&&r.unshift(null),C){y=Sa(y,C);const M=[...r],G=[...d];A=Array.isArray(A)?[...A]:[A];const F=[...A];for(let I=0;I<C;I++){r.push(...M);for(let N=0;N<M.length;N++)d.push(G[N]+(I+1)),A.push(N===0?"linear":Z(F,N-1))}va(d,C)}const H=W+y;Ea(b,r,A,d,W,H),c=Math.max(P+y,c),w=Math.max(H,w)};if(J(V)){const g=_(V,m);v(p,u,q("default",g))}else{const g=Q(V,p,s,S),h=g.length;for(let b=0;b<h;b++){p=p,u=u;const D=g[b],O=_(D,m);for(const r in p)v(p[r],Ia(u,r),q(r,O),b,h)}}x=l,l+=c}return m.forEach((E,f)=>{for(const V in E){const p=E[V];p.sort(xa);const u=[],c=[],v=[];for(let h=0;h<p.length;h++){const{at:b,value:D,easing:O}=p[h];u.push(D),c.push(la(0,w,b)),v.push(O||"easeOut")}c[0]!==0&&(c.unshift(0),u.unshift(u[0]),v.unshift(Da)),c[c.length-1]!==1&&(c.push(1),u.push(null)),i.has(f)||i.set(f,{keyframes:{},transition:{}});const g=i.get(f);g.keyframes[V]=u,g.transition[V]={...a,duration:w,ease:v,times:c,...t}}}),i}function _(e,a){return!a.has(e)&&a.set(e,{}),a.get(e)}function q(e,a){return a[e]||(a[e]=[]),a[e]}function Ma(e){return Array.isArray(e)?e:[e]}function Ia(e,a){return e&&e[a]?{...e,...e[a]}:{...e}}const Na=e=>typeof e=="number",wa=e=>e.every(Na);function Ca(e,a){return e in a}class Ga extends ua{constructor(){super(...arguments),this.type="object"}readValueFromInstance(a,t){if(Ca(t,a)){const s=a[t];if(typeof s=="string"||typeof s=="number")return s}}getBaseTargetFromProps(){}removeValueFromRenderState(a,t){delete t.output[a]}measureInstanceViewportBox(){return ca()}build(a,t){Object.assign(a.output,t)}renderInstance(a,{output:t}){Object.assign(a,t)}sortInstanceNodePosition(){return 0}}function Fa(e){const a={presenceContext:null,props:{},visualState:{renderState:{transform:{},transformOrigin:{},style:{},vars:{},attrs:{}},latestValues:{}}},t=ma(e)&&!fa(e)?new pa(a):new ga(a);t.mount(e),K.set(e,t)}function Ka(e){const a={presenceContext:null,props:{},visualState:{renderState:{output:{}},latestValues:{}}},t=new Ga(a);t.mount(e),K.set(e,t)}function Ba(e,a){return J(e)||typeof e=="number"||typeof e=="string"&&!j(a)}function X(e,a,t,s){const n=[];if(Ba(e,a))n.push(ha(e,j(a)&&a.default||a,t&&(t.default||t)));else{const o=Q(e,a,s),i=o.length;for(let m=0;m<i;m++){const S=o[m],T=S instanceof Element?Fa:Ka;K.has(S)||T(S);const x=K.get(S),l={...t};"delay"in l&&typeof l.delay=="function"&&(l.delay=l.delay(m,i)),n.push(...da(x,{...a,transition:l},{}))}}return n}function La(e,a,t){const s=[];return Oa(e,a,t,{spring:ya}).forEach(({keyframes:o,transition:i},m)=>{s.push(...X(m,o,i))}),s}function ja(e){return Array.isArray(e)&&e.some(Array.isArray)}function Pa(e){function a(t,s,n){let o=[];return ja(t)?o=La(t,s,e):o=X(t,s,n,e),new Va(o)}return a}const za=Pa();export{_a as AsyncMotionValueAnimation,qa as DOMKeyframesResolver,Aa as GroupAnimation,Va as GroupAnimationWithThen,Ja as JSAnimation,Za as KeyframeResolver,Qa as MotionGlobalConfig,Xa as MotionValue,Ya as NativeAnimation,$a as NativeAnimationExtended,ae as SubscriptionManager,ee as addUniqueItem,te as alpha,se as analyseComplexValue,za as animate,ne as anticipate,ie as attachSpring,re as backIn,oe as backInOut,le as backOut,ue as calcGeneratorDuration,ce as cancelFrame,me as circIn,fe as circInOut,pe as circOut,ge as clamp,he as collectMotionValues,de as color,ye as complex,be as convertOffsetToTimes,na as createGeneratorEasing,Ae as createRenderBatcher,Pa as createScopedAnimate,Ve as cubicBezier,Se as cubicBezierAsString,Te as defaultEasing,sa as defaultOffset,Ee as defaultTransformValue,ve as defaultValueTypes,xe as degrees,De as dimensionValueTypes,Oe as distance,Me as distance2D,Ie as easeIn,Ne as easeInOut,we as easeOut,Ce as easingDefinitionToFunction,ia as fillOffset,Ge as fillWildcards,Fe as findDimensionValueType,Ke as findValueType,Be as flushKeyframeResolvers,Le as frame,je as frameData,Pe as frameSteps,Re as generateLinearEasing,ke as getAnimatableNone,We as getDefaultValueType,Z as getEasingForSegment,ze as getMixer,He as getValueAsType,Ue as getValueTransition,_e as getVariableValue,qe as hex,Je as hover,Ze as hsla,Qe as hslaToRgba,Xe as inertia,Ye as interpolate,$e as invariant,at as invisibleValues,et as isBezierDefinition,tt as isCSSVariableName,st as isCSSVariableToken,nt as isDragActive,it as isDragging,$ as isEasingArray,ra as isGenerator,rt as isHTMLElement,J as isMotionValue,ot as isNodeOrChild,lt as isNumericalString,ut as isObject,ct as isPrimaryPointer,ma as isSVGElement,fa as isSVGSVGElement,mt as isZeroValueString,ft as keyframes,pt as mapEasingToNativeEasing,gt as maxGeneratorDuration,ht as memo,dt as microtask,yt as millisecondsToSeconds,bt as mirrorEasing,At as mix,Vt as mixArray,St as mixColor,Tt as mixComplex,Et as mixImmediate,vt as mixLinearColor,ea as mixNumber,xt as mixObject,Dt as mixVisibility,Ot as motionValue,Mt as noop,It as number,Nt as numberValueTypes,wt as observeTimeline,Ct as parseCSSVariable,Gt as parseValueFromTransform,Ft as percent,Kt as pipe,Bt as positionalKeys,Lt as press,la as progress,jt as progressPercentage,Pt as px,Rt as readTransformValue,ta as removeItem,kt as resize,aa as resolveElements,Wt as reverseEasing,zt as rgbUnit,Ht as rgba,Ut as scale,_t as scroll,qt as scrollInfo,oa as secondsToMilliseconds,Jt as setDragLock,Zt as setStyle,ya as spring,Qt as startWaapiAnimation,Xt as supportedWaapiEasing,Yt as supportsBrowserAnimation,$t as supportsFlags,as as supportsLinearEasing,es as supportsScrollTimeline,ts as testValueType,ss as time,ns as transform,is as transformPropOrder,rs as transformProps,os as transformValueTypes,ls as velocityPerSecond,us as vh,cs as vw,ms as warning,ba as wrap};
